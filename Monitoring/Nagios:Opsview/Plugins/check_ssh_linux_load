#!/usr/bin/env python3
##############################################################################
'''
Description:	Opsview/Nagios plugin used to monitor linux CPU via ssh

Requirements:	Requires a username/password or username/ssh key

Created:	    2019-05-15

Author:		    Bo Smith (bo@bosmith.tech)
'''
##############################################################################
import argparse
import io
import paramiko
import sys

ok = 0
warn = 1
crit = 2
unknown = 3
cmd = 'cat /proc/loadavg'


# Get arguments
##############################################################################
def get_args():
    parser = argparse.ArgumentParser(
        usage='%(prog)s [-H] [-u] [-p]',
        description='Opsview plugin to remotely monitor Linux CPU via SSH')
    parser.add_argument(
        '-H',
        '--host',
        action='store',
        required=True,
        help='Host name or IP address'
    )
    parser.add_argument(
        '-s',
        '--sshkey',
        action='store',
        default='',
        required=False,
        help='Path to SSH Key file'
    )
    parser.add_argument(
        '-ss',
        '--sshkeystring',
        action='store',
        default='',
        required=False,
        help='SSH Key as String'
    )
    parser.add_argument(
        '-u',
        '--username',
        action='store',
        default='',
        required=False,
        help='Username to SSH to the appliance (Assumed \'opsview\' if blank'
    )
    parser.add_argument(
        '-p',
        '--password',
        action='store',
        default='',
        required=False,
        help='Password for the user'
    )
    parser.add_argument(
        '-P',
        '--port',
        action='store',
        required=False,
        default=22,
        type=int,
        help='SSH Port to use (Default 22)'
    )
    parser.add_argument(
        '-r',
        '--percpu',
        action='store_true',
        required=False,
        default=False,
        help='Divide the load averages by the number of CPUs'
    )
    parser.add_argument(
        '-t',
        '--timeout',
        action='store',
        required=False,
        default=15,
        type=int,
        help='Timeout in Seconds to wait for an SSH connection (default 15)'
    )
    parser.add_argument(
        '-w',
        '--warning',
        action='store',
        required=False,
        help='WLOAD1,WLOAD5,WLOAD15: Exit with WARNING status if load exceeds '
    )
    parser.add_argument(
        '-c',
        '--critical',
        action='store',
        required=False,
        help='CLOAD,CLOAD5,CLOAD15: Exit with CRITICAL status if load exceeds '
    )
    args = parser.parse_args()
    if (args.username == None and args.sshkey == None):
        print("Either a username and password combination or ssh key is required")
        print(parser.print_help())
        sys.exit(unknown)
    if args.warning and len(args.warning) < 5:
        print("Warning threshold requires 3 entries 1minute,5minute,15minute")
        print(parser.print_help())
        sys.exit(unknown)
    if args.critical and len(args.critical) < 5:
        print("Critical threshold requires 3 entries 1minute,5minute,15minute")
        print(parser.print_help())
        sys.exit(unknown)
    return(args)


# Setup and create Paramiko connection object
##############################################################################
def setup_ssh(args):
    try:
        # Prep client
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        # Build kwargs used to setup ssh connection
        clientargs = {
            'banner_timeout': args.timeout,
            'timeout': args.timeout,
            'password': args.password,
            'port': args.port,
            'username': args.username
        }
        # Add ssh key from file if provided as file path
        if args.sshkey:
            clientargs['key_filename'] = args.sshkey
        # Add ssh key from string if provided as string
        elif args.sshkeystring:
            s = io.StringIO(args.sshkeystring.replace('\\n', '\n'))
            opsvkey = paramiko.RSAKey.from_private_key(
                s,
                password=args.password
            )
            clientargs['pkey'] = opsvkey
        # Setup Connection
        client.connect(args.host, **clientargs)
    except paramiko.AuthenticationException as err:
        message = 'Authentication failed '+str(err)
        send_unknown(message)
    except paramiko.SSHException as err:
        message = 'Unable to establish SSH connection '+str(err)
        send_unknown(message)
    except IOError as err:
        message = 'Timed Out attempting SSH connection'
        send_unknown(message)
    except Exception as err:
        message = 'Unable to establish SSH connection '+str(err)
        send_unknown(message)
    return(client)

# Get the cpu count
##############################################################################


def get_cpu_count(client):
    try:
        stdin, stdout, stderr = client.exec_command('nproc', get_pty=True)
    except Exception as err:
        send_unknown(str(err))
    results = stdout.readlines()
    # CA-594: Add logic to strip first output line if it's "/usr/bin/id: cannot find name for group ID"
    # This is to handle unpredictable addition of extra output for OSLogin hosts in GCP
    if 'id: cannot find name' in results[0]:
        del results[0]
    return(results)


# Gather the Metrics
##############################################################################
def get_load(client, cmd):
    try:
        stdin, stdout, stderr = client.exec_command(cmd, get_pty=True)
    except Exception as err:
        send_unknown(str(err))
    results = stdout.readlines()
    # CA-594: Add logic to strip first output line if it's "/usr/bin/id: cannot find name for group ID"
    # This is to handle unpredictable addition of extra output for OSLogin hosts in GCP
    if 'id: cannot find name' in results[0]:
        del results[0]
    return(results)


# Process Stats
##############################################################################
def process_stats(stats, args, cpucount):
    load1, load5, load15 = stats[0].split(" ")[:3]

    # CPU count retured from server will need help, otherwise its fine
    try:
        cpus = cpucount[0].strip()
    except:
        cpus = cpucount

    # Annoying way to make sure all thresholds are floats ...
    if args.warning:
        try:
            wload1, wload5, wload15 = args.warning.split(",")
        except:
            send_unknown(
                "Unable to parse warning threshold, ensure values are comma separated")
        wload1 = float(wload1)
        wload5 = float(wload5)
        wload15 = float(wload15)
    if args.critical:
        try:
            cload1, cload5, cload15 = args.critical.split(",")
        except:
            send_unknown(
                "Unable to parse critical threshold, ensure values are comma separated")
        cload1 = float(cload1)
        cload5 = float(cload5)
        cload15 = float(cload15)

    # Divide average by num of cpus
    # if -r is not set cpus = 1
    load1 = float(load1) / float(cpus)
    load5 = float(load5) / float(cpus)
    load15 = float(load15) / float(cpus)

    # Prep presentation of data
    message = "load average: {}, {}, {}".format(
        str(load1),
        str(load5),
        str(load15))
    message += " | load1={} load5={} load15={}".format(
        str(load1),
        str(load5),
        str(load15))
    # If we want both Critical and Warning alerts
    if args.critical and args.warning:
        if (load1 >= cload1 or load5 >= cload5 or load15 >= cload15):
            send_critical(message)
        elif (load1 >= wload1 or load5 >= wload5 or load15 >= wload15):
            send_warning(message)
        else:
            send_ok(message)
    # If we just want critical alerts
    elif args.critical:
        if (load1 >= cload1 or load5 >= cload5 or load15 >= cload15):
            send_critical(message)
        else:
            send_ok(message)
    # If we just want warning alerts
    elif args.warning:
        if (load1 >= wload1 or load5 >= wload5 or load15 >= wload15):
            send_warning(message)
        else:
            send_ok(message)
    # If we only want to gather the metrics and not alert
    else:
        send_ok(message)


# Alert Functions
##############################################################################
def send_warning(message):
    print('WARNING - '+message)
    sys.exit(warn)


def send_critical(message):
    print('CRITICAL - '+message)
    sys.exit(crit)


def send_ok(message):
    print('OK - '+message)
    sys.exit(ok)


def send_unknown(message):
    print('UNKNOWN - '+message)
    sys.exit(unknown)


# Git-r-done!
##############################################################################
def main():
    args = get_args()
    client = setup_ssh(args)
    cpucount = get_cpu_count(client) if args.percpu == True else float(1)
    stats = get_load(client, cmd)
    client.close()
    process_stats(stats, args, cpucount)


if __name__ == "__main__":
    main()
